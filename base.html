<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>20-Second Microgames</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* General body styling */
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%); /* Gradient background */
            color: #fff;
            overflow: hidden; /* Prevent scrolling */
            padding: 20px; /* Add some padding around the content */
            box-sizing: border-box;
        }

        /* Main game container */
        .game-container {
            background-color: rgba(0, 0, 0, 0.7); /* Semi-transparent dark background */
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 600px; /* Max width for larger screens */
            width: 100%; /* Full width on smaller screens */
            box-sizing: border-box;
            border: 2px solid #a8dadc; /* Border for the container */
            position: relative;
            z-index: 1;
        }

        /* Game title */
        h1 {
            color: #f1faee;
            margin-bottom: 20px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        /* Game instructions and messages */
        #game-instructions, #game-message {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #a8dadc;
            min-height: 24px; /* Ensure consistent height */
        }

        /* Game timer */
        #game-timer {
            font-size: 1.8em;
            font-weight: bold;
            color: #e63946;
            margin-bottom: 20px;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
        }

        /* Canvas styling */
        canvas {
            background-color: #f1faee; /* Light background for canvas */
            border-radius: 10px;
            border: 2px solid #457b9d;
            display: block; /* Remove extra space below canvas */
            margin: 0 auto 20px auto; /* Center canvas and add bottom margin */
            width: 100%; /* Make canvas responsive */
            max-width: 500px; /* Max width for canvas */
            height: 300px; /* Fixed height for canvas, can be adjusted */
            cursor: pointer; /* Indicate interactivity */
        }

        /* Button styling */
        button {
            background: linear-gradient(45deg, #e63946 0%, #f4a261 100%); /* Gradient button */
            color: #fff;
            border: none;
            border-radius: 10px;
            padding: 12px 25px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(230, 57, 70, 0.4);
            letter-spacing: 1px;
            text-transform: uppercase;
            outline: none; /* Remove outline on focus */
            margin: 5px; /* Add margin for multiple buttons */
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 20px rgba(230, 57, 70, 0.6);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 3px 10px rgba(230, 57, 70, 0.3);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }

        /* Modal for messages (win/lose) */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 100; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.8); /* Black w/ opacity */
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #457b9d;
            margin: auto;
            padding: 30px;
            border: 1px solid #888;
            width: 80%; /* Could be more responsive */
            max-width: 400px;
            text-align: center;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.6);
            color: #fff;
        }

        .modal-content h2 {
            margin-top: 0;
            color: #f1faee;
            font-size: 2em;
        }

        .modal-content p {
            font-size: 1.2em;
            margin-bottom: 20px;
        }

        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px; /* Space between buttons */
            margin-top: 20px;
        }

        .modal-buttons button {
            background: #f4a261;
            box-shadow: 0 5px 15px rgba(244, 162, 97, 0.4);
        }

        .modal-buttons button:hover {
            background: #e63946;
            box-shadow: 0 8px 20px rgba(230, 57, 70, 0.6);
        }

        /* Game selection dropdown */
        #game-selector {
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #457b9d;
            background-color: #f1faee;
            color: #2d3a4b;
            font-size: 1.1em;
            cursor: pointer;
            outline: none;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        /* Buttons container for Start/Pause */
        .game-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            h1 {
                font-size: 2em;
            }
            #game-instructions, #game-message {
                font-size: 1em;
            }
            #game-timer {
                font-size: 1.5em;
            }
            button {
                padding: 10px 20px;
                font-size: 1em;
            }
            .game-container {
                padding: 20px;
                margin: 10px;
            }
            canvas {
                height: 250px; /* Adjust canvas height for smaller screens */
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 1.8em;
            }
            .game-container {
                padding: 15px;
            }
            canvas {
                height: 200px; /* Further adjust canvas height */
            }
            .modal-buttons, .game-controls {
                flex-direction: column; /* Stack buttons on small screens */
            }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <h1>20-Second Microgames</h1>
        <p id="game-instructions">Select a game and click "Start Game"!</p>
        <p id="game-timer">Time: 20.00</p>
        <canvas id="gameCanvas" width="500" height="300"></canvas>
        <p id="game-message"></p>
        <select id="game-selector"></select>
        <div class="game-controls">
            <button id="startGameButton">Start Game</button>
            <button id="pauseGameButton" style="display:none;">Pause</button>
        </div>
    </div>

    <div id="gameModal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle"></h2>
            <p id="modalMessage"></p>
            <div class="modal-buttons">
                <button id="modalPlayAgainButton">Play Again</button>
                <button id="modalCloseButton">Close</button>
            </div>
        </div>
    </div>

    <script>
        // Get DOM elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startGameButton = document.getElementById('startGameButton');
        const pauseGameButton = document.getElementById('pauseGameButton');
        const gameInstructions = document.getElementById('game-instructions');
        const gameTimer = document.getElementById('game-timer');
        const gameMessage = document.getElementById('game-message');
        const gameModal = document.getElementById('gameModal');
        const modalTitle = document.getElementById('modalTitle');
        const modalMessage = document.getElementById('modalMessage');
        const modalPlayAgainButton = document.getElementById('modalPlayAgainButton');
        const modalCloseButton = document.getElementById('modalCloseButton');
        const gameSelector = document.getElementById('game-selector');

        // Game state variables
        let gameActive = false;
        let gamePaused = false;
        let gameStartTime;
        let gamePauseTime = 0;
        let lastFrameTime = 0;
        let gameDuration = 20 * 1000; // 20 seconds in milliseconds
        let currentMicrogame = null;
        let animationFrameId;
        let matchGameTimeout = null; // Declared globally for Memory Match
        let mazeGameTimeout = null; // Declared globally for Maze Runner if needed for timeouts

        // --- Game Definitions ---
        const games = [
            { id: 'cat-asleep', name: 'Keep the Cat Asleep' },
            { id: 'ufo-abduction', name: 'Don\'t Let the UFO Abduct You' },
            { id: 'catch-stars', name: 'Catch the Falling Stars' },
            { id: 'avoid-lasers', name: 'Avoid the Lasers' },
            { id: 'remember-sequence', name: 'Remember the Sequence' },
            { id: 'click-target', name: 'Click the Target' },
            { id: 'balance-ball', name: 'Balance the Ball' },
            { id: 'quick-reflexes', name: 'Quick Reflexes' },
            { id: 'memory-match', name: 'Memory Match (Pairs)' }, // Updated name
            { id: 'maze-runner', name: 'Maze Runner' } // New game
        ];

        // Game 1: Keep the Cat Asleep variables
        const CAT_ASLEEP_GAME_ID = 'cat-asleep';
        const cat = { x: 0, y: 0, radius: 40 };
        let noises = [];
        let noiseInterval;

        // Game 2: Don't Let the UFO Abduct You variables
        const UFO_GAME_ID = 'ufo-abduction';
        const player = { x: 0, y: 0, width: 30, height: 30, speed: 5 };
        const ufo = { x: 0, y: 50, width: 80, height: 40, speed: 2, targetX: 0 };
        let ufoBeamActive = false;
        let ufoBeamDuration = 0;
        const MAX_BEAM_DURATION = 1000;
        let keysPressed = {};
        let touchStartX = 0;

        // Game 3: Catch the Falling Stars variables
        const CATCH_STARS_GAME_ID = 'catch-stars';
        let stars = [];
        let starSpawnInterval;
        let score = 0;

        // Game 4: Avoid the Lasers variables
        const AVOID_LASERS_GAME_ID = 'avoid-lasers';
        const laserPlayer = { x: 0, y: 0, radius: 15, speed: 6 };
        let lasers = [];
        let laserSpawnInterval;
        let laserKeysPressed = {};
        let laserTouchStartX = 0;
        const LASER_WARNING_DURATION = 500;
        const LASER_SPEED_INCREASE = 2;
        const LASER_SPAWN_FREQUENCY = 600;

        // Game 5: Remember the Sequence variables
        const REMEMBER_SEQUENCE_GAME_ID = 'remember-sequence';
        const sequenceButtons = [
            { id: 0, x: 0, y: 0, size: 80, color: '#4B0082', highlightColor: '#9932CC' }, // Indigo -> Dark Orchid
            { id: 1, x: 0, y: 0, size: 80, color: '#8B0000', highlightColor: '#FF6347' }, // Dark Red -> Tomato
            { id: 2, x: 0, y: 0, size: 80, color: '#006400', highlightColor: '#7CFC00' }, // Dark Green -> Lawn Green
            { id: 3, x: 0, y: 0, size: 80, color: '#FF8C00', highlightColor: '#FFD700' }  // Dark Orange -> Gold
        ];
        let gameSequence = [];
        let playerSequence = [];
        let sequenceStep = 0;
        let displayPhase = true;
        let displayTimer = 0;
        const DISPLAY_DURATION = 700;
        const PAUSE_DURATION = 150;
        let currentHighlightButton = -1;
        let sequenceGameTimeout;

        // Game 7: Click the Target variables
        const CLICK_TARGET_GAME_ID = 'click-target';
        const target = { x: 0, y: 0, radius: 20, hit: false };
        let targetScore = 0;
        let targetSpawnTimeout;
        const TARGET_MIN_RADIUS = 10;
        const TARGET_MAX_RADIUS = 30;
        const TARGET_SPAWN_INTERVAL = 800;
        const TARGET_LIFETIME = 1500;

        // Game 8: Balance the Ball variables
        const BALANCE_BALL_GAME_ID = 'balance-ball';
        const platform = { x: 0, y: 0, width: 100, height: 15, speed: 7 };
        const ball = { x: 0, y: 0, radius: 10, dx: 0, dy: 0, speed: 4 };
        let ballKeysPressed = {};
        let ballTouchStartX = 0;

        // Game 9: Quick Reflexes variables
        const QUICK_REFLEXES_GAME_ID = 'quick-reflexes';
        const reflexButton = { x: 0, y: 0, size: 100, color: 'gray' };
        const REFLEX_COLORS = ['#FF4500', '#008000', '#4169E1', '#FFD700', '#8A2BE2', '#00CED1'];
        const REFLEX_TARGET_COLOR = '#008000';
        let reflexScore = 0;
        let colorChangeIntervalId;
        const COLOR_CHANGE_RATE = 400;
        const REFLEX_CLICK_WINDOW = 200;

        // Game 10: Memory Match variables (REVISED)
        const MEMORY_MATCH_GAME_ID = 'memory-match';
        const matchGrid = { rows: 3, cols: 4 }; // Changed to 3x4 for 12 cards (even number for pairs)
        const cardSize = 80;
        const cardPadding = 15;
        let matchCards = []; // Array of { x, y, size, symbol, isFlipped, isMatched }
        let flippedCards = []; // Stores the 1 or 2 cards currently flipped
        let awaitingSecondClick = false; // Prevents clicking more than 2 cards
        let matchedPairs = 0;
        const MATCH_CARD_BACK_COLOR = '#457b9d'; // Blue-grey
        const MATCH_CARD_MATCHED_COLOR = '#2a9d8f'; // Green for matched cards
        const MATCH_CARD_MISMATCH_COLOR = '#e63946'; // Red for mismatched cards (briefly)

        // Game 11: Maze Runner (NEW GAME)
        const MAZE_RUNNER_GAME_ID = 'maze-runner';
        const mazePlayer = { x: 0, y: 0, size: 15, speed: 3 };
        const mazeExit = { x: 0, y: 0, size: 20 };
        const mazeWallThickness = 10;
        let mazeWalls = []; // Array of { x, y, width, height }
        let mazeKeysPressed = {};
        let mazeTouchStartX = 0;
        let mazeTouchStartY = 0;


        // --- Utility Functions ---

        /**
         * Shows a modal message to the user.
         * @param {string} title - The title of the modal.
         * @param {string} message - The message content.
         */
        function showModal(title, message) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            gameModal.style.display = 'flex';
        }

        /**
         * Hides the modal.
         */
        function hideModal() {
            gameModal.style.display = 'none';
        }

        /**
         * Clears the canvas.
         */
        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

        /**
         * Shuffles an array in place.
         * @param {Array} array - The array to shuffle.
         */
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        /**
         * Stops the current game loop and clears intervals.
         */
        function stopGameLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            if (noiseInterval) {
                clearInterval(noiseInterval);
            }
            if (starSpawnInterval) {
                clearInterval(starSpawnInterval);
            }
            if (laserSpawnInterval) {
                clearInterval(laserSpawnInterval);
            }
            if (sequenceGameTimeout) {
                clearTimeout(sequenceGameTimeout);
            }
            if (targetSpawnTimeout) {
                clearTimeout(targetSpawnTimeout);
            }
            if (colorChangeIntervalId) {
                clearInterval(colorChangeIntervalId);
            }
            if (matchGameTimeout) { // Now correctly referenced as a global variable
                clearTimeout(matchGameTimeout);
            }
            if (mazeGameTimeout) { // Clear timeout for Maze Runner if applicable
                clearTimeout(mazeGameTimeout);
            }

            gameActive = false;
            gamePaused = false;
            startGameButton.disabled = false;
            startGameButton.textContent = 'Start Game';
            gameSelector.disabled = false;
            pauseGameButton.style.display = 'none';
            pauseGameButton.textContent = 'Pause';
        }

        /**
         * Ends the current game with a win or lose message.
         * @param {boolean} win - True if the player won, false otherwise.
         * @param {string} message - A specific message for the outcome.
         */
        function endGame(win, message) {
            stopGameLoop();
            cleanupAllListeners();

            if (win) {
                gameMessage.textContent = 'You Win!';
                gameMessage.style.color = '#2a9d8f';
                showModal('Victory!', message || 'You successfully completed the challenge!');
            } else {
                gameMessage.textContent = 'Game Over!';
                gameMessage.style.color = '#e63946';
                showModal('Game Over!', message || 'You failed the challenge!');
            }
            gameTimer.textContent = 'Time: 0.00';
        }

        /**
         * Toggles the game's paused state.
         */
        function togglePause() {
            if (!gameActive) return;

            gamePaused = !gamePaused;
            if (gamePaused) {
                pauseGameButton.textContent = 'Resume';
                gamePauseTime += performance.now() - lastFrameTime;
                cancelAnimationFrame(animationFrameId);
                gameInstructions.textContent = "Game Paused. Click 'Resume' to continue.";
                gameMessage.textContent = "";
            } else {
                pauseGameButton.textContent = 'Pause';
                lastFrameTime = performance.now();
                animationFrameId = requestAnimationFrame(gameLoop);
                switch (currentMicrogame) {
                    case CAT_ASLEEP_GAME_ID:
                        gameInstructions.textContent = "Keep the cat asleep! Click the noises before they reach the cat.";
                        break;
                    case UFO_GAME_ID:
                        gameInstructions.textContent = "Don't let the UFO abduct you! Use arrow keys or drag to move.";
                        break;
                    case CATCH_STARS_GAME_ID:
                        gameInstructions.textContent = "Catch the falling stars! Click or tap them before they hit the ground.";
                        break;
                    case AVOID_LASERS_GAME_ID:
                        gameInstructions.textContent = "Avoid the lasers! Move your character to dodge the incoming beams.";
                        break;
                    case REMEMBER_SEQUENCE_GAME_ID:
                        gameInstructions.textContent = "Remember the sequence! Watch the lights, then repeat them.";
                        if (displayPhase) {
                             clearTimeout(sequenceGameTimeout);
                             startSequenceDisplay();
                        }
                        break;
                    case CLICK_TARGET_GAME_ID:
                        gameInstructions.textContent = "Click the target! Hit it before it disappears.";
                        break;
                    case BALANCE_BALL_GAME_ID:
                        gameInstructions.textContent = "Balance the ball! Use arrow keys or drag to move the platform.";
                        break;
                    case QUICK_REFLEXES_GAME_ID:
                        gameInstructions.textContent = "Click the button when it turns GREEN!";
                        break;
                    case MEMORY_MATCH_GAME_ID:
                        gameInstructions.textContent = "Find all the matching pairs!";
                        break;
                    case MAZE_RUNNER_GAME_ID: // New game instruction
                        gameInstructions.textContent = "Navigate the maze to the exit! Use arrow keys or drag.";
                        break;
                }
            }
        }


        // --- Game 1: Keep the Cat Asleep ---

        /**
         * Initializes the "Keep the Cat Asleep" game.
         */
        function initCatAsleepGame() {
            gameInstructions.textContent = "Keep the cat asleep! Click the noises before they reach the cat.";
            gameMessage.textContent = "";
            noises = [];
            cat.x = canvas.width / 2;
            cat.y = canvas.height / 2 + 30;

            noiseInterval = setInterval(() => {
                if (!gamePaused) {
                    noises.push({
                        x: Math.random() * canvas.width,
                        y: 0,
                        radius: 10 + Math.random() * 10,
                        speed: 1 + Math.random() * 2,
                        color: `hsl(${Math.random() * 360}, 70%, 60%)`
                    });
                }
            }, 800 + Math.random() * 700);

            canvas.addEventListener('click', handleCatAsleepClick);
            canvas.addEventListener('touchstart', handleCatAsleepClick);
        }

        /**
         * Draws the cat on the canvas.
         */
        function drawCat() {
            ctx.fillStyle = '#457b9d';
            ctx.beginPath();
            ctx.arc(cat.x, cat.y, cat.radius, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(cat.x - cat.radius * 0.7, cat.y - cat.radius);
            ctx.lineTo(cat.x - cat.radius * 0.3, cat.y - cat.radius * 1.5);
            ctx.lineTo(cat.x, cat.y - cat.radius);
            ctx.fill();

            ctx.beginPath();
            ctx.moveTo(cat.x + cat.radius * 0.7, cat.y - cat.radius);
            ctx.lineTo(cat.x + cat.radius * 0.3, cat.y - cat.radius * 1.5);
            ctx.lineTo(cat.x, cat.y - cat.radius);
            ctx.fill();

            ctx.strokeStyle = '#2d3a4b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(cat.x - cat.radius * 0.3, cat.y - cat.radius * 0.2, 5, 0, Math.PI, true);
            ctx.stroke();
            ctx.beginPath();
            ctx.arc(cat.x + cat.radius * 0.3, cat.y - cat.radius * 0.2, 5, 0, Math.PI, true);
            ctx.stroke();
        }

        /**
         * Draws and updates noises.
         */
        function drawNoises() {
            for (let i = noises.length - 1; i >= 0; i--) {
                const noise = noises[i];
                noise.y += noise.speed;

                ctx.fillStyle = noise.color;
                ctx.beginPath();
                ctx.arc(noise.x, noise.y, noise.radius, 0, Math.PI * 2);
                ctx.fill();

                const dist = Math.sqrt(Math.pow(noise.x - cat.x, 2) + Math.pow(noise.y - cat.y, 2));
                if (dist < noise.radius + cat.radius) {
                    endGame(false, 'A noise woke the cat!');
                    return;
                }

                if (noise.y > canvas.height + noise.radius) {
                    noises.splice(i, 1);
                }
            }
        }

        /**
         * Handles click/tap events for the "Keep the Cat Asleep" game.
         * @param {MouseEvent|TouchEvent} event - The click/touch event.
         */
        function handleCatAsleepClick(event) {
            if (!gameActive || gamePaused) return;

            let clickX, clickY;
            if (event.type === 'touchstart') {
                clickX = event.touches[0].clientX - canvas.getBoundingClientRect().left;
                clickY = event.touches[0].clientY - canvas.getBoundingClientRect().top;
            } else {
                clickX = event.clientX - canvas.getBoundingClientRect().left;
                clickY = event.clientY - canvas.getBoundingClientRect().top;
            }

            for (let i = noises.length - 1; i >= 0; i--) {
                const noise = noises[i];
                const dist = Math.sqrt(Math.pow(clickX - noise.x, 2) + Math.pow(clickY - noise.y, 2));
                if (dist < noise.radius) {
                    noises.splice(i, 1);
                    break;
                }
            }
        }

        /**
         * Cleans up event listeners specific to the Cat Asleep game.
         */
        function cleanupCatAsleepListeners() {
            canvas.removeEventListener('click', handleCatAsleepClick);
            canvas.removeEventListener('touchstart', handleCatAsleepClick);
        }

        // --- Game 2: Don't Let the UFO Abduct You ---

        /**
         * Initializes the "Don't Let the UFO Abduct You" game.
         */
        function initUfoGame() {
            gameInstructions.textContent = "Don't let the UFO abduct you! Use arrow keys or drag to move.";
            gameMessage.textContent = "";
            player.x = canvas.width / 2 - player.width / 2;
            player.y = canvas.height - 50;
            ufo.x = canvas.width / 2;
            ufo.targetX = canvas.width / 2;
            ufoBeamActive = false;
            ufoBeamDuration = 0;
            keysPressed = {};

            document.addEventListener('keydown', handleKeyDownUFO);
            document.addEventListener('keyup', handleKeyUpUFO);
            canvas.addEventListener('touchstart', handleTouchStartUFO);
            canvas.addEventListener('touchmove', handleTouchMoveUFO);
            canvas.addEventListener('touchend', handleTouchEndUFO);
        }

        /**
         * Draws the player character.
         */
        function drawPlayer() {
            ctx.fillStyle = '#2a9d8f';
            ctx.fillRect(player.x, player.y, player.width, player.height);

            ctx.beginPath();
            ctx.arc(player.x + player.width / 2, player.y - 10, 10, 0, Math.PI * 2);
            ctx.fill();
        }

        /**
         * Draws the UFO.
         */
        function drawUFO() {
            ctx.fillStyle = '#a8dadc';
            ctx.beginPath();
            ctx.ellipse(ufo.x, ufo.y, ufo.width / 2, ufo.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#457b9d';
            ctx.beginPath();
            ctx.arc(ufo.x, ufo.y - ufo.height / 4, ufo.width * 0.3, 0, Math.PI * 2);
            ctx.fill();

            if (ufoBeamActive) {
                ctx.fillStyle = 'rgba(255, 255, 100, 0.4)';
                ctx.beginPath();
                ctx.moveTo(ufo.x - ufo.width * 0.3, ufo.y + ufo.height / 2);
                ctx.lineTo(ufo.x - ufo.width * 0.6, canvas.height);
                ctx.lineTo(ufo.x + ufo.width * 0.6, canvas.height);
                ctx.lineTo(ufo.x + ufo.width * 0.3, ufo.y + ufo.height / 2);
                ctx.closePath();
                ctx.fill();
            }
        }

        /**
         * Updates UFO and player positions, checks for abduction.
         */
        function updateUFOAndPlayer() {
            if (ufo.x < ufo.targetX) {
                ufo.x += ufo.speed;
            } else if (ufo.x > ufo.targetX) {
                ufo.x -= ufo.speed;
            }

            if (Math.abs(ufo.x - ufo.targetX) < 5) {
                ufo.targetX = Math.random() * (canvas.width - ufo.width) + ufo.width / 2;
            }

            if (keysPressed['ArrowLeft'] || keysPressed['a']) {
                player.x -= player.speed;
            }
            if (keysPressed['ArrowRight'] || keysPressed['d']) {
                player.x += player.speed;
            }

            if (player.x < 0) player.x = 0;
            if (player.x + player.width > canvas.width) player.x = canvas.width - player.width;

            const beamLeft = ufo.x - ufo.width * 0.6;
            const beamRight = ufo.x + ufo.width * 0.6;
            const playerCenter = player.x + player.width / 2;

            if (playerCenter > beamLeft && playerCenter < beamRight) {
                ufoBeamActive = true;
                ufoBeamDuration += 1000 / 60;
                if (ufoBeamDuration >= MAX_BEAM_DURATION) {
                    endGame(false, 'You were abducted by the UFO!');
                }
            } else {
                ufoBeamActive = false;
                ufoBeamDuration = Math.max(0, ufoBeamDuration - 50);
            }
        }

        /**
         * Handles keydown events for UFO game.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyDownUFO(event) {
            if (gamePaused) return;
            keysPressed[event.key] = true;
        }

        /**
         * Handles keyup events for UFO game.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyUpUFO(event) {
            if (gamePaused) return;
            keysPressed[event.key] = false;
        }

        /**
         * Handles touchstart for UFO game.
         * @param {TouchEvent} event - The touch event.
         */
        function handleTouchStartUFO(event) {
            if (!gameActive || gamePaused) return;
            touchStartX = event.touches[0].clientX;
        }

        /**
         * Handles touchmove for UFO game.
         * @param {TouchEvent} event - The touch event.
         */
        function handleTouchMoveUFO(event) {
            if (!gameActive || gamePaused) return;
            const touchCurrentX = event.touches[0].clientX;
            const deltaX = touchCurrentX - touchStartX;
            player.x += deltaX * 0.5;
            touchStartX = touchCurrentX;
            event.preventDefault();
        }

        /**
         * Handles touchend for UFO game.
         */
        function handleTouchEndUFO() {
            // No specific action needed on touchend for continuous movement
        }

        /**
         * Cleans up event listeners specific to the UFO game.
         */
        function cleanupUfoGameListeners() {
            document.removeEventListener('keydown', handleKeyDownUFO);
            document.removeEventListener('keyup', handleKeyUpUFO);
            canvas.removeEventListener('touchstart', handleTouchStartUFO);
            canvas.removeEventListener('touchmove', handleTouchMoveUFO);
            canvas.removeEventListener('touchend', handleTouchEndUFO);
        }

        // --- Game 3: Catch the Falling Stars ---

        /**
         * Initializes the "Catch the Falling Stars" game.
         */
        function initCatchStarsGame() {
            gameInstructions.textContent = "Catch the falling stars! Click or tap them before they hit the ground.";
            gameMessage.textContent = "";
            stars = [];
            score = 0;

            starSpawnInterval = setInterval(() => {
                if (!gamePaused) {
                    stars.push({
                        x: Math.random() * canvas.width,
                        y: 0,
                        radius: 10 + Math.random() * 10,
                        speed: 1 + Math.random() * 2,
                        color: `hsl(${Math.random() * 60 + 30}, 90%, 70%)`
                    });
                }
            }, 400 + Math.random() * 600);

            canvas.addEventListener('click', handleCatchStarsClick);
            canvas.addEventListener('touchstart', handleCatchStarsClick);
        }

        /**
         * Draws a star (simple polygon).
         * @param {object} star - The star object.
         */
        function drawStar(star) {
            ctx.fillStyle = star.color;
            ctx.beginPath();
            const spikes = 5;
            const outerRadius = star.radius;
            const innerRadius = star.radius / 2;
            let rot = Math.PI / 2 * 3;
            let x = star.x;
            let y = star.y;
            let step = Math.PI / spikes;

            ctx.moveTo(x, y - outerRadius);
            for (let i = 0; i < spikes; i++) {
                x = star.x + Math.cos(rot) * outerRadius;
                y = star.y + Math.sin(rot) * outerRadius;
                ctx.lineTo(x, y);
                rot += step;

                x = star.x + Math.cos(rot) * innerRadius;
                y = star.y + Math.sin(rot) * innerRadius;
                ctx.lineTo(x, y);
                rot += step;
            }
            ctx.lineTo(star.x, star.y - outerRadius);
            ctx.closePath();
            ctx.fill();
        }

        /**
         * Draws and updates falling stars.
         */
        function drawStars() {
            for (let i = stars.length - 1; i >= 0; i--) {
                const star = stars[i];
                star.y += star.speed;

                drawStar(star);

                if (star.y > canvas.height - star.radius) {
                    endGame(false, `A star hit the ground! You caught ${score} stars.`);
                    return;
                }
            }
            gameMessage.textContent = `Stars Caught: ${score}`;
        }

        /**
         * Handles click/tap events for "Catch the Falling Stars" game.
         * @param {MouseEvent|TouchEvent} event - The click/touch event.
         */
        function handleCatchStarsClick(event) {
            if (!gameActive || gamePaused) return;

            let clickX, clickY;
            if (event.type === 'touchstart') {
                clickX = event.touches[0].clientX - canvas.getBoundingClientRect().left;
                clickY = event.touches[0].clientY - canvas.getBoundingClientRect().top;
            } else {
                clickX = event.clientX - canvas.getBoundingClientRect().left;
                clickY = event.clientY - canvas.getBoundingClientRect().top;
            }

            for (let i = stars.length - 1; i >= 0; i--) {
                const star = stars[i];
                const dist = Math.sqrt(Math.pow(clickX - star.x, 2) + Math.pow(clickY - star.y, 2));
                if (dist < star.radius) {
                    stars.splice(i, 1);
                    score++;
                    break;
                }
            }
        }

        /**
         * Cleans up event listeners specific to the Catch Stars game.
         */
        function cleanupCatchStarsListeners() {
            canvas.removeEventListener('click', handleCatchStarsClick);
            canvas.removeEventListener('touchstart', handleCatchStarsClick);
        }

        // --- Game 4: Avoid the Lasers ---

        /**
         * Initializes the "Avoid the Lasers" game.
         */
        function initAvoidLasersGame() {
            gameInstructions.textContent = "Avoid the lasers! Move your character to dodge the incoming beams.";
            gameMessage.textContent = "";
            lasers = [];
            laserPlayer.x = canvas.width / 2;
            laserPlayer.y = canvas.height / 2;
            laserKeysPressed = {};

            laserSpawnInterval = setInterval(() => {
                if (!gamePaused) {
                    const edge = Math.floor(Math.random() * 4); // 0:top, 1:right, 2:bottom, 3:left
                    let startX, startY, endX, endY;
                    let speed = (2 + Math.random() * 3) * LASER_SPEED_INCREASE;

                    switch (edge) {
                        case 0: // Top
                            startX = Math.random() * canvas.width;
                            startY = 0;
                            endX = Math.random() * canvas.width;
                            endY = canvas.height;
                            break;
                        case 1: // Right
                            startX = canvas.width;
                            startY = Math.random() * canvas.height;
                            endX = 0;
                            endY = Math.random() * canvas.height;
                            break;
                        case 2: // Bottom
                            startX = Math.random() * canvas.width;
                            startY = canvas.height;
                            endX = Math.random() * canvas.width;
                            endY = 0;
                            break;
                        case 3: // Left
                            startX = 0;
                            startY = Math.random() * canvas.height;
                            endX = canvas.width;
                            endY = Math.random() * canvas.height;
                            break;
                    }

                    lasers.push({
                        startX: startX,
                        startY: startY,
                        endX: endX,
                        endY: endY,
                        currentX: startX,
                        currentY: startY,
                        progress: 0,
                        speed: speed / 100,
                        width: 10,
                        warningPhase: true,
                        warningStartTime: performance.now(),
                        active: false
                    });
                }
            }, LASER_SPAWN_FREQUENCY + Math.random() * 200);

            document.addEventListener('keydown', handleKeyDownAvoidLasers);
            document.addEventListener('keyup', handleKeyUpAvoidLasers);
            canvas.addEventListener('touchstart', handleTouchStartAvoidLasers);
            canvas.addEventListener('touchmove', handleTouchMoveAvoidLasers);
            canvas.addEventListener('touchend', handleTouchEndAvoidLasers);
        }

        /**
         * Draws the player for the laser game.
         */
        function drawLaserPlayer() {
            ctx.fillStyle = '#2a9d8f';
            ctx.beginPath();
            ctx.arc(laserPlayer.x, laserPlayer.y, laserPlayer.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        /**
         * Draws and updates lasers.
         */
        function drawLasers() {
            for (let i = lasers.length - 1; i >= 0; i--) {
                const laser = lasers[i];

                if (laser.warningPhase) {
                    const elapsedTime = performance.now() - laser.warningStartTime;
                    if (elapsedTime < LASER_WARNING_DURATION) {
                        ctx.fillStyle = (Math.floor(elapsedTime / 100) % 2 === 0) ? 'rgba(255, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
                        ctx.beginPath();
                        ctx.moveTo(laser.startX, laser.startY);
                        ctx.lineTo(laser.endX, laser.endY);
                        ctx.lineWidth = laser.width;
                        ctx.lineCap = 'round';
                        ctx.stroke();
                        ctx.lineCap = 'butt';
                    } else {
                        laser.warningPhase = false;
                        laser.active = true;
                    }
                } else if (laser.active) {
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.6)';

                    laser.progress += laser.speed;
                    if (laser.progress > 1) {
                        lasers.splice(i, 1);
                        continue;
                    }

                    laser.currentX = laser.startX + (laser.endX - laser.startX) * laser.progress;
                    laser.currentY = laser.startY + (laser.endY - laser.startY) * laser.progress;

                    ctx.beginPath();
                    ctx.moveTo(laser.startX, laser.startY);
                    ctx.lineTo(laser.currentX, laser.currentY);
                    ctx.lineWidth = laser.width;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    ctx.lineCap = 'butt';

                    const dx = laser.endX - laser.startX;
                    const dy = laser.endY - laser.startY;
                    const lenSq = dx * dx + dy * dy;
                    let t = 0;
                    if (lenSq !== 0) {
                        t = ((laserPlayer.x - laser.startX) * dx + (laserPlayer.y - laser.startY) * dy) / lenSq;
                        t = Math.max(0, Math.min(1, t));
                    }

                    const closestX = laser.startX + t * dx;
                    const closestY = laser.startY + t * dy;

                    const distSq = Math.pow(laserPlayer.x - closestX, 2) + Math.pow(laserPlayer.y - closestY, 2);

                    if (distSq < Math.pow(laserPlayer.radius + laser.width / 2, 2)) {
                        endGame(false, 'You were hit by a laser!');
                        return;
                    }
                }
            }
        }

        /**
         * Updates player position for laser game.
         */
        function updateLaserPlayer() {
            if (laserKeysPressed['ArrowUp'] || laserKeysPressed['w']) {
                laserPlayer.y -= laserPlayer.speed;
            }
            if (laserKeysPressed['ArrowDown'] || laserKeysPressed['s']) {
                laserPlayer.y += laserPlayer.speed;
            }
            if (laserKeysPressed['ArrowLeft'] || laserKeysPressed['a']) {
                laserPlayer.x -= laserPlayer.speed;
            }
            if (laserKeysPressed['ArrowRight'] || laserKeysPressed['d']) {
                laserPlayer.x += laserPlayer.speed;
            }

            if (laserPlayer.x < laserPlayer.radius) laserPlayer.x = laserPlayer.radius;
            if (laserPlayer.x > canvas.width - laserPlayer.radius) laserPlayer.x = canvas.width - laserPlayer.radius;
            if (laserPlayer.y < laserPlayer.radius) laserPlayer.y = laserPlayer.radius;
            if (laserPlayer.y > canvas.height - laserPlayer.radius) laserPlayer.y = canvas.height - laserPlayer.radius;
        }

        /**
         * Handles keydown events for Avoid Lasers game.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyDownAvoidLasers(event) {
            if (gamePaused) return;
            laserKeysPressed[event.key] = true;
        }

        /**
         * Handles keyup events for Avoid Lasers game.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyUpAvoidLasers(event) {
            if (gamePaused) return;
            laserKeysPressed[event.key] = false;
        }

        /**
         * Handles touchstart for Avoid Lasers game.
         * @param {TouchEvent} event - The touch event.
         */
        function handleTouchStartAvoidLasers(event) {
            if (!gameActive || gamePaused) return;
            laserTouchStartX = event.touches[0].clientX;
            laserPlayer.touchStartY = event.touches[0].clientY;
        }

        /**
         * Handles touchmove for Avoid Lasers game.
         * @param {TouchEvent} event - The touch event.
         */
        function handleTouchMoveAvoidLasers(event) {
            if (!gameActive || gamePaused) return;
            const touchCurrentX = event.touches[0].clientX;
            const touchCurrentY = event.touches[0].clientY;
            const deltaX = touchCurrentX - laserTouchStartX;
            const deltaY = touchCurrentY - laserPlayer.touchStartY;

            laserPlayer.x += deltaX * 0.5;
            laserPlayer.y += deltaY * 0.5;

            laserTouchStartX = touchCurrentX;
            laserPlayer.touchStartY = touchCurrentY;

            event.preventDefault();
        }

        /**
         * Handles touchend for Avoid Lasers game.
         */
        function handleTouchEndAvoidLasers() {
            // No specific action needed on touchend for continuous movement
        }

        /**
         * Cleans up event listeners specific to the Avoid Lasers game.
         */
        function cleanupAvoidLasersListeners() {
            document.removeEventListener('keydown', handleKeyDownAvoidLasers);
            document.removeEventListener('keyup', handleKeyUpAvoidLasers);
            canvas.removeEventListener('touchstart', handleTouchStartAvoidLasers);
            canvas.removeEventListener('touchmove', handleTouchMoveAvoidLasers);
            canvas.removeEventListener('touchend', handleTouchEndAvoidLasers);
        }

        // --- Game 5: Remember the Sequence ---

        /**
         * Initializes the "Remember the Sequence" game.
         */
        function initRememberSequenceGame() {
            gameInstructions.textContent = "Remember the sequence! Watch the lights, then repeat them.";
            gameMessage.textContent = "";
            gameSequence = [];
            playerSequence = [];
            sequenceStep = 0;
            displayPhase = true;
            displayTimer = 0;
            currentHighlightButton = -1;

            const totalWidth = sequenceButtons[0].size * 2 + 20;
            const totalHeight = sequenceButtons[0].size * 2 + 20;
            const startX = (canvas.width - totalWidth) / 2;
            const startY = (canvas.height - totalHeight) / 2;

            sequenceButtons[0].x = startX + sequenceButtons[0].size / 2;
            sequenceButtons[0].y = startY + sequenceButtons[0].size / 2;

            sequenceButtons[1].x = startX + sequenceButtons[0].size * 1.5 + 20;
            sequenceButtons[1].y = startY + sequenceButtons[0].size / 2;

            sequenceButtons[2].x = startX + sequenceButtons[0].size / 2;
            sequenceButtons[2].y = startY + sequenceButtons[0].size * 1.5 + 20;

            sequenceButtons[3].x = startX + sequenceButtons[0].size * 1.5 + 20;
            sequenceButtons[3].y = startY + sequenceButtons[0].size * 1.5 + 20;


            const sequenceLength = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < sequenceLength; i++) {
                gameSequence.push(Math.floor(Math.random() * sequenceButtons.length));
            }

            startSequenceDisplay();

            canvas.addEventListener('click', handleRememberSequenceClick);
            canvas.addEventListener('touchstart', handleRememberSequenceClick);
        }

        /**
         * Starts the sequence display phase.
         */
        function startSequenceDisplay() {
            displayPhase = true;
            sequenceStep = 0;
            playerSequence = [];
            gameMessage.textContent = "Watch carefully...";
            sequenceGameTimeout = setTimeout(showNextSequenceLight, PAUSE_DURATION);
        }

        /**
         * Shows the next light in the sequence.
         */
        function showNextSequenceLight() {
            if (gamePaused) return;

            if (sequenceStep < gameSequence.length) {
                currentHighlightButton = gameSequence[sequenceStep];
                sequenceStep++;
                sequenceGameTimeout = setTimeout(() => {
                    currentHighlightButton = -1;
                    sequenceGameTimeout = setTimeout(showNextSequenceLight, PAUSE_DURATION);
                }, DISPLAY_DURATION);
            } else {
                displayPhase = false;
                sequenceStep = 0;
                gameMessage.textContent = "Your turn!";
                currentHighlightButton = -1;
            }
        }

        /**
         * Draws the sequence buttons.
         */
        function drawSequenceButtons() {
            sequenceButtons.forEach((button, index) => {
                ctx.fillStyle = (index === currentHighlightButton) ? button.highlightColor : button.color;
                ctx.beginPath();
                ctx.arc(button.x, button.y, button.size / 2, 0, Math.PI * 2);
                ctx.fill();
                ctx.strokeStyle = '#2d3a4b';
                ctx.lineWidth = 3;
                ctx.stroke();
            });
        }

        /**
         * Handles click/tap events for Remember the Sequence.
         * @param {MouseEvent|TouchEvent} event - The click/touch event.
         */
        function handleRememberSequenceClick(event) {
            if (!gameActive || gamePaused || displayPhase) return;

            let clickX, clickY;
            if (event.type === 'touchstart') {
                clickX = event.touches[0].clientX - canvas.getBoundingClientRect().left;
                clickY = event.touches[0].clientY - canvas.getBoundingClientRect().top;
            } else {
                clickX = event.clientX - canvas.getBoundingClientRect().left;
                clickY = event.clientY - canvas.getBoundingClientRect().top;
            }

            let clickedButtonId = -1;
            for (let i = 0; i < sequenceButtons.length; i++) {
                const button = sequenceButtons[i];
                const dist = Math.sqrt(Math.pow(clickX - button.x, 2) + Math.pow(clickY - button.y, 2));
                if (dist < button.size / 2) {
                    clickedButtonId = button.id;
                    break;
                }
            }

            if (clickedButtonId !== -1) {
                currentHighlightButton = clickedButtonId;
                setTimeout(() => {
                    currentHighlightButton = -1;
                }, 100);

                playerSequence.push(clickedButtonId);

                if (playerSequence[sequenceStep] === gameSequence[sequenceStep]) {
                    sequenceStep++;
                    if (sequenceStep === gameSequence.length) {
                        endGame(true, 'Sequence remembered!');
                    }
                } else {
                    endGame(false, 'Incorrect sequence!');
                }
            }
        }

        /**
         * Cleans up event listeners specific to the Remember the Sequence game.
         */
        function cleanupRememberSequenceListeners() {
            canvas.removeEventListener('click', handleRememberSequenceClick);
            canvas.removeEventListener('touchstart', handleRememberSequenceClick);
            if (sequenceGameTimeout) {
                clearTimeout(sequenceGameTimeout);
            }
        }

        // --- Game 7: Click the Target ---

        /**
         * Initializes the "Click the Target" game.
         */
        function initClickTargetGame() {
            gameInstructions.textContent = "Click the target! Hit it before it disappears.";
            gameMessage.textContent = `Score: 0`;
            targetScore = 0;
            target.hit = true;
            spawnTarget();

            canvas.addEventListener('click', handleClickTarget);
            canvas.addEventListener('touchstart', handleClickTarget);
        }

        /**
         * Spawns a new target.
         */
        function spawnTarget() {
            if (gamePaused) return;

            if (!target.hit) {
                targetScore--;
                gameMessage.textContent = `Score: ${targetScore}`;
                if (targetScore < -5) {
                    endGame(false, `You missed too many targets! Final score: ${targetScore}`);
                    return;
                }
            }

            target.x = Math.random() * (canvas.width - TARGET_MAX_RADIUS * 2) + TARGET_MAX_RADIUS;
            target.y = Math.random() * (canvas.height - TARGET_MAX_RADIUS * 2) + TARGET_MAX_RADIUS;
            target.radius = TARGET_MAX_RADIUS - Math.random() * (TARGET_MAX_RADIUS - TARGET_MIN_RADIUS);
            target.hit = false;
            target.spawnTime = performance.now();

            if (targetSpawnTimeout) clearTimeout(targetSpawnTimeout);
            targetSpawnTimeout = setTimeout(spawnTarget, TARGET_LIFETIME);
        }

        /**
         * Draws the target.
         */
        function drawTarget() {
            if (!target.hit) {
                const elapsedTime = performance.now() - target.spawnTime;
                let alpha = 1;

                if (elapsedTime > TARGET_LIFETIME * 0.7) {
                    alpha = 1 - ((elapsedTime - TARGET_LIFETIME * 0.7) / (TARGET_LIFETIME * 0.3));
                }

                ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`;
                ctx.beginPath();
                ctx.arc(target.x, target.y, target.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        /**
         * Handles click/tap events for Click the Target.
         * @param {MouseEvent|TouchEvent} event - The click/touch event.
         */
        function handleClickTarget(event) {
            if (!gameActive || gamePaused || target.hit) return;

            let clickX, clickY;
            if (event.type === 'touchstart') {
                clickX = event.touches[0].clientX - canvas.getBoundingClientRect().left;
                clickY = event.touches[0].clientY - canvas.getBoundingClientRect().top;
            } else {
                clickX = event.clientX - canvas.getBoundingClientRect().left;
                clickY = event.clientY - canvas.getBoundingClientRect().top;
            }

            const dist = Math.sqrt(Math.pow(clickX - target.x, 2) + Math.pow(clickY - target.y, 2));
            if (dist < target.radius) {
                target.hit = true;
                targetScore++;
                gameMessage.textContent = `Score: ${targetScore}`;
                if (targetSpawnTimeout) clearTimeout(targetSpawnTimeout);
                targetSpawnTimeout = setTimeout(spawnTarget, TARGET_SPAWN_INTERVAL);
            }
        }

        /**
         * Cleans up event listeners specific to Click the Target game.
         */
        function cleanupClickTargetListeners() {
            canvas.removeEventListener('click', handleClickTarget);
            canvas.removeEventListener('touchstart', handleClickTarget);
            if (targetSpawnTimeout) {
                clearTimeout(targetSpawnTimeout);
            }
        }

        // --- Game 8: Balance the Ball ---

        /**
         * Initializes the "Balance the Ball" game.
         */
        function initBalanceBallGame() {
            gameInstructions.textContent = "Balance the ball! Use arrow keys or drag to move the platform.";
            gameMessage.textContent = "";

            platform.width = 100;
            platform.x = canvas.width / 2 - platform.width / 2;
            platform.y = canvas.height - 30;

            ball.x = canvas.width / 2;
            ball.y = platform.y - ball.radius;
            ball.dx = (Math.random() > 0.5 ? 1 : -1) * ball.speed;
            ball.dy = -ball.speed;

            ballKeysPressed = {};

            document.addEventListener('keydown', handleKeyDownBall);
            document.addEventListener('keyup', handleKeyUpBall);
            canvas.addEventListener('touchstart', handleTouchStartBall);
            canvas.addEventListener('touchmove', handleTouchMoveBall);
            canvas.addEventListener('touchend', handleTouchEndBall);
        }

        /**
         * Draws the platform.
         */
        function drawPlatform() {
            ctx.fillStyle = '#457b9d';
            ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
        }

        /**
         * Draws the ball.
         */
        function drawBall() {
            ctx.fillStyle = '#e63946';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        /**
         * Updates ball and platform positions and checks for collisions.
         */
        function updateBallAndPlatform() {
            // Move platform
            if (ballKeysPressed['ArrowLeft'] || ballKeysPressed['a']) {
                platform.x -= platform.speed;
            }
            if (ballKeysPressed['ArrowRight'] || ballKeysPressed['d']) {
                platform.x += platform.speed;
            }

            // Keep platform within bounds
            if (platform.x < 0) platform.x = 0;
            if (platform.x + platform.width > canvas.width) platform.x = canvas.width - platform.width;

            // Move ball
            ball.x += ball.dx;
            ball.y += ball.dy;

            // Ball collision with walls
            if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                ball.dx *= -1;
            }
            if (ball.y - ball.radius < 0) {
                ball.dy *= -1;
            }

            // Ball collision with platform
            if (
                ball.y + ball.radius > platform.y &&
                ball.y - ball.radius < platform.y + platform.height &&
                ball.x + ball.radius > platform.x &&
                ball.x - ball.radius < platform.x + platform.width
            ) {
                ball.y = platform.y - ball.radius;
                ball.dy *= -1;

                const hitPoint = (ball.x - platform.x) / platform.width;
                ball.dx = (hitPoint - 0.5) * 2 * ball.speed;
            }

            // Ball falls off bottom
            if (ball.y + ball.radius > canvas.height) {
                endGame(false, 'The ball fell!');
            }
        }

        /**
         * Handles keydown events for Balance the Ball game.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyDownBall(event) {
            if (gamePaused) return;
            ballKeysPressed[event.key] = true;
        }

        /**
         * Handles keyup events for Balance the Ball game.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyUpBall(event) {
            if (gamePaused) return;
            ballKeysPressed[event.key] = false;
        }

        /**
         * Handles touchstart for Balance the Ball game.
         * @param {TouchEvent} event - The touch event.
         */
        function handleTouchStartBall(event) {
            if (!gameActive || gamePaused) return;
            ballTouchStartX = event.touches[0].clientX;
        }

        /**
         * Handles touchmove for Balance the Ball game.
         * @param {TouchEvent} event - The touch event.
         */
        function handleTouchMoveBall(event) {
            if (!gameActive || gamePaused) return;
            const touchCurrentX = event.touches[0].clientX;
            const deltaX = touchCurrentX - ballTouchStartX;
            platform.x += deltaX * 1.5;
            ballTouchStartX = touchCurrentX;
            event.preventDefault();
        }

        /**
         * Handles touchend for Balance the Ball game.
         */
        function handleTouchEndBall() {
            // No specific action needed on touchend
        }

        /**
         * Cleans up event listeners specific to Balance the Ball game.
         */
        function cleanupBalanceBallListeners() {
            document.removeEventListener('keydown', handleKeyDownBall);
            document.removeEventListener('keyup', handleKeyUpBall);
            canvas.removeEventListener('touchstart', handleTouchStartBall);
            canvas.removeEventListener('touchmove', handleTouchMoveBall);
            canvas.removeEventListener('touchend', handleTouchEndBall);
        }

        // --- Game 9: Quick Reflexes ---

        /**
         * Initializes the "Quick Reflexes" game.
         */
        function initQuickReflexesGame() {
            gameInstructions.textContent = "Click the button when it turns GREEN!";
            gameMessage.textContent = `Score: 0`;
            reflexScore = 0;
            reflexButton.x = canvas.width / 2;
            reflexButton.y = canvas.height / 2;
            reflexButton.color = REFLEX_COLORS[0];

            colorChangeIntervalId = setInterval(changeReflexButtonColor, COLOR_CHANGE_RATE);

            canvas.addEventListener('click', handleQuickReflexesClick);
            canvas.addEventListener('touchstart', handleQuickReflexesClick);
        }

        /**
         * Changes the color of the reflex button.
         */
        function changeReflexButtonColor() {
            if (gamePaused) return;

            let newColor;
            do {
                newColor = REFLEX_COLORS[Math.floor(Math.random() * REFLEX_COLORS.length)];
            } while (newColor === reflexButton.color);

            reflexButton.color = newColor;
        }

        /**
         * Draws the reflex button.
         */
        function drawReflexButton() {
            ctx.fillStyle = reflexButton.color;
            ctx.beginPath();
            ctx.arc(reflexButton.x, reflexButton.y, reflexButton.size / 2, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.fillStyle = '#2d3a4b';
            ctx.font = 'bold 24px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`Score: ${reflexScore}`, canvas.width / 2, canvas.height - 30);
        }

        /**
         * Handles click/tap events for Quick Reflexes.
         * @param {MouseEvent|TouchEvent} event - The click/touch event.
         */
        function handleQuickReflexesClick(event) {
            if (!gameActive || gamePaused) return;

            let clickX, clickY;
            if (event.type === 'touchstart') {
                clickX = event.touches[0].clientX - canvas.getBoundingClientRect().left;
                clickY = event.touches[0].clientY - canvas.getBoundingClientRect().top;
            } else {
                clickX = event.clientX - canvas.getBoundingClientRect().left;
                clickY = event.clientY - canvas.getBoundingClientRect().top;
            }

            const dist = Math.sqrt(Math.pow(clickX - reflexButton.x, 2) + Math.pow(clickY - reflexButton.y, 2));

            if (dist < reflexButton.size / 2) {
                if (reflexButton.color === REFLEX_TARGET_COLOR) {
                    reflexScore++;
                    gameMessage.textContent = `Score: ${reflexScore}`;
                    changeReflexButtonColor();
                } else {
                    reflexScore--; // Deduct point for wrong color
                    gameMessage.textContent = `Score: ${reflexScore}`;
                    if (reflexScore < -5) { // Lose if score drops too low
                        endGame(false, `Too many wrong clicks! Final score: ${reflexScore}`);
                        return;
                    }
                    changeReflexButtonColor(); // Change color even on wrong click
                }
            } else {
                reflexScore--; // Deduct point for missing button
                gameMessage.textContent = `Score: ${reflexScore}`;
                if (reflexScore < -5) { // Lose if score drops too low
                    endGame(false, `You missed the button too many times! Final score: ${reflexScore}`);
                    return;
                }
                // No color change on miss, button stays same color as it was
            }
        }

        /**
         * Cleans up event listeners specific to Quick Reflexes game.
         */
        function cleanupQuickReflexesListeners() {
            canvas.removeEventListener('click', handleQuickReflexesClick);
            canvas.removeEventListener('touchstart', handleQuickReflexesClick);
            if (colorChangeIntervalId) {
                clearInterval(colorChangeIntervalId);
            }
        }

        // --- Game 10: Memory Match --- (REVISED to be a true pair-matching game)

        /**
         * Initializes the "Memory Match" game.
         */
        function initMemoryMatchGame() {
            gameInstructions.textContent = "Find all the matching pairs!";
            gameMessage.textContent = `Matched Pairs: 0 / ${ (matchGrid.rows * matchGrid.cols) / 2}`;
            matchCards = [];
            flippedCards = [];
            awaitingSecondClick = false;
            matchedPairs = 0;

            const numCards = matchGrid.rows * matchGrid.cols;
            const symbols = ['', '', '', '', '', '', '', '', '', '', '', '']; // More emojis
            const availableSymbols = symbols.slice(0, numCards / 2); // Use enough symbols for pairs

            let cardSymbols = [];
            for (let i = 0; i < numCards / 2; i++) {
                cardSymbols.push(availableSymbols[i]);
                cardSymbols.push(availableSymbols[i]);
            }
            shuffleArray(cardSymbols);

            const totalGridWidth = matchGrid.cols * cardSize + (matchGrid.cols - 1) * cardPadding;
            const totalGridHeight = matchGrid.rows * cardSize + (matchGrid.rows - 1) * cardPadding;
            const startX = (canvas.width - totalGridWidth) / 2;
            const startY = (canvas.height - totalGridHeight) / 2;

            for (let r = 0; r < matchGrid.rows; r++) {
                for (let c = 0; c < matchGrid.cols; c++) {
                    const x = startX + c * (cardSize + cardPadding) + cardSize / 2;
                    const y = startY + r * (cardSize + cardPadding) + cardSize / 2;
                    matchCards.push({
                        x: x,
                        y: y,
                        size: cardSize,
                        symbol: cardSymbols.pop(),
                        isFlipped: false,
                        isMatched: false
                    });
                }
            }

            canvas.addEventListener('click', handleMemoryMatchClick);
            canvas.addEventListener('touchstart', handleMemoryMatchClick);
        }

        /**
         * Draws the Memory Match cards.
         */
        function drawMemoryMatchCards() {
            ctx.font = `${cardSize * 0.6}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            matchCards.forEach(card => {
                ctx.beginPath();
                ctx.roundRect(card.x - card.size / 2, card.y - card.size / 2, card.size, card.size, 10);

                if (card.isMatched) {
                    ctx.fillStyle = MATCH_CARD_MATCHED_COLOR;
                } else if (card.isFlipped) {
                    ctx.fillStyle = '#f1faee'; // Color when flipped
                } else {
                    ctx.fillStyle = MATCH_CARD_BACK_COLOR;
                }
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();

                if (card.isFlipped || card.isMatched) {
                    ctx.fillStyle = '#2d3a4b';
                    ctx.fillText(card.symbol, card.x, card.y);
                }
            });

            gameMessage.textContent = `Matched Pairs: ${matchedPairs} / ${ (matchGrid.rows * matchGrid.cols) / 2}`;
        }

        /**
         * Handles click/tap events for Memory Match.
         * @param {MouseEvent|TouchEvent} event - The click/touch event.
         */
        function handleMemoryMatchClick(event) {
            if (!gameActive || gamePaused || awaitingSecondClick) return;

            let clickX, clickY;
            if (event.type === 'touchstart') {
                clickX = event.touches[0].clientX - canvas.getBoundingClientRect().left;
                clickY = event.touches[0].clientY - canvas.getBoundingClientRect().top;
            } else {
                clickX = event.clientX - canvas.getBoundingClientRect().left;
                clickY = event.clientY - canvas.getBoundingClientRect().top;
            }

            let clickedCard = null;
            for (let i = 0; i < matchCards.length; i++) {
                const card = matchCards[i];
                const dist = Math.sqrt(Math.pow(clickX - card.x, 2) + Math.pow(clickY - card.y, 2));
                if (dist < card.size / 2 && !card.isFlipped && !card.isMatched) {
                    clickedCard = card;
                    break;
                }
            }

            if (clickedCard) {
                clickedCard.isFlipped = true;
                flippedCards.push(clickedCard);

                if (flippedCards.length === 2) {
                    awaitingSecondClick = true;
                    if (flippedCards[0].symbol === flippedCards[1].symbol) {
                        // Match found
                        flippedCards[0].isMatched = true;
                        flippedCards[1].isMatched = true;
                        matchedPairs++;
                        flippedCards = []; // Clear flipped cards
                        awaitingSecondClick = false; // Allow new clicks immediately

                        if (matchedPairs === (matchGrid.rows * matchGrid.cols) / 2) {
                            endGame(true, `You matched all pairs!`);
                        }
                    } else {
                        // No match, flip back after a delay
                        setTimeout(() => {
                            flippedCards[0].isFlipped = false;
                            flippedCards[1].isFlipped = false;
                            flippedCards = [];
                            awaitingSecondClick = false;
                        }, 1000);
                    }
                }
            }
        }

        /**
         * Cleans up event listeners specific to Memory Match game.
         */
        function cleanupMemoryMatchListeners() {
            canvas.removeEventListener('click', handleMemoryMatchClick);
            canvas.removeEventListener('touchstart', handleMemoryMatchClick);
            // Clear any pending timeouts for flipping cards back
            // (This is implicitly handled by `awaitingSecondClick` and resetting `flippedCards` on game end)
        }

        // --- Game 11: Maze Runner --- (NEW GAME)

        /**
         * Generates a simple maze.
         * This is a basic example; a more complex maze generation algorithm could be used.
         */
        function generateMaze() {
            mazeWalls = [];
            const wallSize = mazeWallThickness;

            // Outer boundary walls
            mazeWalls.push({ x: 0, y: 0, width: canvas.width, height: wallSize }); // Top
            mazeWalls.push({ x: 0, y: canvas.height - wallSize, width: canvas.width, height: wallSize }); // Bottom
            mazeWalls.push({ x: 0, y: 0, width: wallSize, height: canvas.height }); // Left
            mazeWalls.push({ x: canvas.width - wallSize, y: 0, width: wallSize, height: canvas.height }); // Right

            // Simple internal walls (can be randomized or more complex)
            mazeWalls.push({ x: canvas.width / 3, y: 0, width: wallSize, height: canvas.height / 2 });
            mazeWalls.push({ x: canvas.width / 3, y: canvas.height / 2 + 50, width: wallSize, height: canvas.height / 2 - 50 });
            mazeWalls.push({ x: 2 * canvas.width / 3, y: canvas.height / 2, width: wallSize, height: canvas.height / 2 });
            mazeWalls.push({ x: 2 * canvas.width / 3, y: 0, width: wallSize, height: canvas.height / 2 - 50 });
            mazeWalls.push({ x: canvas.width / 4, y: canvas.height / 4, width: canvas.width / 2, height: wallSize });
            mazeWalls.push({ x: canvas.width / 4, y: 3 * canvas.height / 4, width: canvas.width / 2, height: wallSize });

            // Set player start and exit
            mazePlayer.x = wallSize + mazePlayer.size;
            mazePlayer.y = wallSize + mazePlayer.size;
            mazeExit.x = canvas.width - wallSize - mazeExit.size;
            mazeExit.y = canvas.height - wallSize - mazeExit.size;
        }

        /**
         * Initializes the "Maze Runner" game.
         */
        function initMazeRunnerGame() {
            gameInstructions.textContent = "Navigate the maze to the exit! Use arrow keys or drag.";
            gameMessage.textContent = "";
            generateMaze(); // Generate a new maze
            mazeKeysPressed = {};

            document.addEventListener('keydown', handleKeyDownMaze);
            document.addEventListener('keyup', handleKeyUpMaze);
            canvas.addEventListener('touchstart', handleTouchStartMaze);
            canvas.addEventListener('touchmove', handleTouchMoveMaze);
            canvas.addEventListener('touchend', handleTouchEndMaze);
        }

        /**
         * Draws the maze walls.
         */
        function drawMazeWalls() {
            ctx.fillStyle = '#2d3a4b'; // Dark blue-grey for walls
            mazeWalls.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
            });
        }

        /**
         * Draws the maze player.
         */
        function drawMazePlayer() {
            ctx.fillStyle = '#e63946'; // Red for player
            ctx.beginPath();
            ctx.arc(mazePlayer.x, mazePlayer.y, mazePlayer.size / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        /**
         * Draws the maze exit.
         */
        function drawMazeExit() {
            ctx.fillStyle = '#2a9d8f'; // Green for exit
            ctx.beginPath();
            ctx.arc(mazeExit.x, mazeExit.y, mazeExit.size / 2, 0, Math.PI * 2);
            ctx.fill();

            // Draw a simple 'E' for Exit
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 16px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('E', mazeExit.x, mazeExit.y);
        }

        /**
         * Updates player position and checks for collisions in Maze Runner.
         */
        function updateMazePlayer() {
            let newX = mazePlayer.x;
            let newY = mazePlayer.y;

            if (mazeKeysPressed['ArrowUp'] || mazeKeysPressed['w']) {
                newY -= mazePlayer.speed;
            }
            if (mazeKeysPressed['ArrowDown'] || mazeKeysPressed['s']) {
                newY += mazePlayer.speed;
            }
            if (mazeKeysPressed['ArrowLeft'] || mazeKeysPressed['a']) {
                newX -= mazePlayer.speed;
            }
            if (mazeKeysPressed['ArrowRight'] || mazeKeysPressed['d']) {
                newX += mazePlayer.speed;
            }

            // Check for wall collisions before updating position
            const playerRect = {
                x: newX - mazePlayer.size / 2,
                y: newY - mazePlayer.size / 2,
                width: mazePlayer.size,
                height: mazePlayer.size
            };

            let collided = false;
            for (const wall of mazeWalls) {
                if (
                    playerRect.x < wall.x + wall.width &&
                    playerRect.x + playerRect.width > wall.x &&
                    playerRect.y < wall.y + wall.height &&
                    playerRect.y + playerRect.height > wall.y
                ) {
                    collided = true;
                    break;
                }
            }

            if (!collided) {
                mazePlayer.x = newX;
                mazePlayer.y = newY;
            }

            // Check for exit collision
            const distToExit = Math.sqrt(
                Math.pow(mazePlayer.x - mazeExit.x, 2) +
                Math.pow(mazePlayer.y - mazeExit.y, 2)
            );
            if (distToExit < mazePlayer.size / 2 + mazeExit.size / 2) {
                endGame(true, 'You found the exit!');
            }
        }

        /**
         * Handles keydown events for Maze Runner.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyDownMaze(event) {
            if (gamePaused) return;
            mazeKeysPressed[event.key] = true;
        }

        /**
         * Handles keyup events for Maze Runner.
         * @param {KeyboardEvent} event - The keyboard event.
         */
        function handleKeyUpMaze(event) {
            if (gamePaused) return;
            mazeKeysPressed[event.key] = false;
        }

        /**
         * Handles touchstart for Maze Runner.
         * @param {TouchEvent} event - The touch event.
         */
        function handleTouchStartMaze(event) {
            if (!gameActive || gamePaused) return;
            mazeTouchStartX = event.touches[0].clientX;
            mazeTouchStartY = event.touches[0].clientY;
        }

        /**
         * Handles touchmove for Maze Runner.
         * @param {TouchEvent} event - The touch event.
         */
        function handleTouchMoveMaze(event) {
            if (!gameActive || gamePaused) return;
            const touchCurrentX = event.touches[0].clientX;
            const touchCurrentY = event.touches[0].clientY;
            const deltaX = touchCurrentX - mazeTouchStartX;
            const deltaY = touchCurrentY - mazeTouchStartY;

            // Move player based on touch drag, adjust sensitivity
            let newX = mazePlayer.x + deltaX * 0.2;
            let newY = mazePlayer.y + deltaY * 0.2;

            // Clamp to canvas bounds
            newX = Math.max(mazePlayer.size / 2, Math.min(canvas.width - mazePlayer.size / 2, newX));
            newY = Math.max(mazePlayer.size / 2, Math.min(canvas.height - mazePlayer.size / 2, newY));

            // Check for wall collisions before updating position
            const playerRect = {
                x: newX - mazePlayer.size / 2,
                y: newY - mazePlayer.size / 2,
                width: mazePlayer.size,
                height: mazePlayer.size
            };

            let collided = false;
            for (const wall of mazeWalls) {
                if (
                    playerRect.x < wall.x + wall.width &&
                    playerRect.x + playerRect.width > wall.x &&
                    playerRect.y < wall.y + wall.height &&
                    playerRect.y + playerRect.height > wall.y
                ) {
                    collided = true;
                    break;
                }
            }

            if (!collided) {
                mazePlayer.x = newX;
                mazePlayer.y = newY;
            }

            mazeTouchStartX = touchCurrentX;
            mazeTouchStartY = touchCurrentY;

            event.preventDefault();
        }

        /**
         * Handles touchend for Maze Runner.
         */
        function handleTouchEndMaze() {
            // No specific action needed on touchend
        }

        /**
         * Cleans up event listeners specific to Maze Runner game.
         */
        function cleanupMazeRunnerListeners() {
            document.removeEventListener('keydown', handleKeyDownMaze);
            document.removeEventListener('keyup', handleKeyUpMaze);
            canvas.removeEventListener('touchstart', handleTouchStartMaze);
            canvas.removeEventListener('touchmove', handleTouchMoveMaze);
            canvas.removeEventListener('touchend', handleTouchEndMaze);
        }


        // --- Main Game Logic ---

        /**
         * The main game loop.
         * @param {DOMHighResTimeStamp} currentTime - The current time provided by requestAnimationFrame.
         */
        function gameLoop(currentTime) {
            if (!gameActive || gamePaused) {
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }

            const elapsedTime = (currentTime - gameStartTime) - gamePauseTime;
            const timeLeft = Math.max(0, gameDuration - elapsedTime);
            gameTimer.textContent = `Time: ${(timeLeft / 1000).toFixed(2)}`;

            clearCanvas();

            switch (currentMicrogame) {
                case CAT_ASLEEP_GAME_ID:
                    drawCat();
                    drawNoises();
                    break;
                case UFO_GAME_ID:
                    drawUFO();
                    drawPlayer();
                    updateUFOAndPlayer();
                    break;
                case CATCH_STARS_GAME_ID:
                    drawStars();
                    break;
                case AVOID_LASERS_GAME_ID:
                    drawLaserPlayer();
                    drawLasers();
                    updateLaserPlayer();
                    break;
                case REMEMBER_SEQUENCE_GAME_ID:
                    drawSequenceButtons();
                    break;
                case CLICK_TARGET_GAME_ID:
                    drawTarget();
                    break;
                case BALANCE_BALL_GAME_ID:
                    drawPlatform();
                    drawBall();
                    updateBallAndPlatform();
                    break;
                case QUICK_REFLEXES_GAME_ID:
                    drawReflexButton();
                    break;
                case MEMORY_MATCH_GAME_ID:
                    drawMemoryMatchCards();
                    break;
                case MAZE_RUNNER_GAME_ID: // New game draw/update
                    drawMazeWalls();
                    drawMazeExit();
                    drawMazePlayer();
                    updateMazePlayer();
                    break;
            }

            if (timeLeft <= 0) {
                let winConditionMet = false;
                let finalMessage = 'You survived the challenge!';

                switch (currentMicrogame) {
                    case REMEMBER_SEQUENCE_GAME_ID:
                        winConditionMet = (sequenceStep === gameSequence.length);
                        finalMessage = winConditionMet ? 'Sequence remembered!' : 'Time ran out before you completed the sequence!';
                        break;
                    case CLICK_TARGET_GAME_ID:
                        winConditionMet = (targetScore >= 0);
                        finalMessage = `Time's up! Your final score: ${targetScore}.`;
                        break;
                    case QUICK_REFLEXES_GAME_ID:
                        winConditionMet = (reflexScore >= 5);
                        finalMessage = `Time's up! Your final score: ${reflexScore}.`;
                        break;
                    case MEMORY_MATCH_GAME_ID:
                        winConditionMet = (matchedPairs === (matchGrid.rows * matchGrid.cols) / 2);
                        finalMessage = winConditionMet ? `Time's up! You matched all pairs!` : `Time's up! You only matched ${matchedPairs} out of ${ (matchGrid.rows * matchGrid.cols) / 2} pairs.`;
                        break;
                    case MAZE_RUNNER_GAME_ID:
                        // Maze Runner win condition is checked within updateMazePlayer, if time runs out, it's a loss
                        winConditionMet = false;
                        finalMessage = 'Time ran out! You did not reach the exit.';
                        break;
                    default:
                        winConditionMet = true;
                        break;
                }
                endGame(winConditionMet, finalMessage);

            } else {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
            lastFrameTime = currentTime;
        }

        /**
         * Cleans up all game-specific event listeners.
         */
        function cleanupAllListeners() {
            cleanupCatAsleepListeners();
            cleanupUfoGameListeners();
            cleanupCatchStarsListeners();
            cleanupAvoidLasersListeners();
            cleanupRememberSequenceListeners();
            cleanupClickTargetListeners();
            cleanupBalanceBallListeners();
            cleanupQuickReflexesListeners();
            cleanupMemoryMatchListeners();
            cleanupMazeRunnerListeners(); // New game cleanup
        }

        /**
         * Starts a new microgame.
         */
        function startGame() {
            stopGameLoop();
            hideModal();
            cleanupAllListeners();

            gameActive = true;
            gamePaused = false;
            gamePauseTime = 0;
            startGameButton.disabled = true;
            gameSelector.disabled = true;
            pauseGameButton.style.display = 'inline-block';
            pauseGameButton.textContent = 'Pause';
            gameMessage.textContent = "";
            gameStartTime = performance.now();
            lastFrameTime = performance.now();

            currentMicrogame = gameSelector.value;

            switch (currentMicrogame) {
                case CAT_ASLEEP_GAME_ID:
                    initCatAsleepGame();
                    break;
                case UFO_GAME_ID:
                    initUfoGame();
                    break;
                case CATCH_STARS_GAME_ID:
                    initCatchStarsGame();
                    break;
                case AVOID_LASERS_GAME_ID:
                    initAvoidLasersGame();
                    break;
                case REMEMBER_SEQUENCE_GAME_ID:
                    initRememberSequenceGame();
                    break;
                case CLICK_TARGET_GAME_ID:
                    initClickTargetGame();
                    break;
                case BALANCE_BALL_GAME_ID:
                    initBalanceBallGame();
                    break;
                case QUICK_REFLEXES_GAME_ID:
                    initQuickReflexesGame();
                    break;
                case MEMORY_MATCH_GAME_ID:
                    initMemoryMatchGame();
                    break;
                case MAZE_RUNNER_GAME_ID: // New game init
                    initMazeRunnerGame();
                    break;
                default:
                    gameInstructions.textContent = "Please select a game to play.";
                    gameActive = false;
                    startGameButton.disabled = false;
                    gameSelector.disabled = false;
                    pauseGameButton.style.display = 'none';
                    return;
            }

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        /**
         * Populates the game selection dropdown.
         */
        function populateGameSelector() {
            gameSelector.innerHTML = '';
            games.forEach(game => {
                const option = document.createElement('option');
                option.value = game.id;
                option.textContent = game.name;
                gameSelector.appendChild(option);
            });
        }

        // --- Event Listeners ---
        startGameButton.addEventListener('click', startGame);
        pauseGameButton.addEventListener('click', togglePause);
        modalPlayAgainButton.addEventListener('click', startGame);
        modalCloseButton.addEventListener('click', () => {
            hideModal();
            stopGameLoop();
            gameInstructions.textContent = "Select a game and click 'Start Game'!";
            gameTimer.textContent = 'Time: 20.00';
            gameMessage.textContent = "";
            gameSelector.disabled = false;
            startGameButton.textContent = 'Start Game';
        });


        // Initial setup
        gameTimer.textContent = 'Time: 20.00';
        gameInstructions.textContent = "Select a game and click 'Start Game'!";
        populateGameSelector();

        // Resize canvas to fit container width
        const resizeCanvas = () => {
            const containerWidth = canvas.parentElement.clientWidth;
            canvas.width = Math.min(containerWidth - 60, 500);
            // Re-initialize game elements that depend on canvas size
            if (currentMicrogame === CAT_ASLEEP_GAME_ID) {
                cat.x = canvas.width / 2;
                cat.y = canvas.height / 2 + 30;
            } else if (currentMicrogame === UFO_GAME_ID) {
                player.x = canvas.width / 2 - player.width / 2;
                player.y = canvas.height - 50;
                ufo.x = canvas.width / 2;
                ufo.targetX = canvas.width / 2;
            } else if (currentMicrogame === CATCH_STARS_GAME_ID) {
                // No specific re-init needed for stars on resize
            } else if (currentMicrogame === AVOID_LASERS_GAME_ID) {
                laserPlayer.x = canvas.width / 2;
                laserPlayer.y = canvas.height / 2;
                // Lasers positions are dynamic, no specific re-init needed on resize unless game is active
            } else if (currentMicrogame === REMEMBER_SEQUENCE_GAME_ID) {
                const totalWidth = sequenceButtons[0].size * 2 + 20;
                const totalHeight = sequenceButtons[0].size * 2 + 20;
                const startX = (canvas.width - totalWidth) / 2;
                const startY = (canvas.height - totalHeight) / 2;

                sequenceButtons[0].x = startX + sequenceButtons[0].size / 2;
                sequenceButtons[0].y = startY + sequenceButtons[0].size / 2;

                sequenceButtons[1].x = startX + sequenceButtons[0].size * 1.5 + 20;
                sequenceButtons[1].y = startY + sequenceButtons[0].size / 2;

                sequenceButtons[2].x = startX + sequenceButtons[0].size / 2;
                sequenceButtons[2].y = startY + sequenceButtons[0].size * 1.5 + 20;

                sequenceButtons[3].x = startX + sequenceButtons[0].size * 1.5 + 20;
                sequenceButtons[3].y = startY + sequenceButtons[0].size * 1.5 + 20;
            } else if (currentMicrogame === CLICK_TARGET_GAME_ID) {
                // Target position is random, no specific re-init needed on resize unless game is active
            } else if (currentMicrogame === BALANCE_BALL_GAME_ID) {
                platform.x = canvas.width / 2 - platform.width / 2;
                platform.y = canvas.height - 30;
                ball.x = canvas.width / 2;
                ball.y = platform.y - ball.radius;
            } else if (currentMicrogame === QUICK_REFLEXES_GAME_ID) {
                reflexButton.x = canvas.width / 2;
                reflexButton.y = canvas.height / 2;
            } else if (currentMicrogame === MEMORY_MATCH_GAME_ID) {
                const totalGridWidth = matchGrid.cols * cardSize + (matchGrid.cols - 1) * cardPadding;
                const totalGridHeight = matchGrid.rows * cardSize + (matchGrid.rows - 1) * cardPadding;
                const startX = (canvas.width - totalGridWidth) / 2;
                const startY = (canvas.height - totalGridHeight) / 2;

                matchCards.forEach((card, i) => {
                    const r = Math.floor(i / matchGrid.cols);
                    const c = i % matchGrid.cols;
                    card.x = startX + c * (cardSize + cardPadding) + cardSize / 2;
                    card.y = startY + r * (cardSize + cardPadding) + cardSize / 2;
                });
            } else if (currentMicrogame === MAZE_RUNNER_GAME_ID) { // New game resize
                generateMaze(); // Re-generate maze on resize to fit new dimensions
            }

            if (gameActive || !currentMicrogame) {
                 clearCanvas();
            }
        };

        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);

    </script>
</body>
</html>
